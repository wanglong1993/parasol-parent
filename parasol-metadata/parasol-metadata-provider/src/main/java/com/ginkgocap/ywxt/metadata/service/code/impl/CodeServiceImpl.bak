package com.ginkgocap.ywxt.metadata.service.code.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.annotation.Resource;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.MessageChannel;
import org.springframework.integration.message.GenericMessage;
import org.springframework.stereotype.Service;

import com.ginkgocap.ywxt.metadata.dao.code.CodeDao;
import com.ginkgocap.ywxt.metadata.dao.code.RCodeDockDao;
import com.ginkgocap.ywxt.metadata.form.DataGridModel;
import com.ginkgocap.ywxt.metadata.form.TreeNode;
import com.ginkgocap.ywxt.metadata.model.Code;
import com.ginkgocap.ywxt.metadata.model.CodeLog;
import com.ginkgocap.ywxt.metadata.model.CodeRegion;
import com.ginkgocap.ywxt.metadata.model.RCodeDock;
import com.ginkgocap.ywxt.metadata.service.code.CodeLogService;
import com.ginkgocap.ywxt.metadata.service.code.CodeService;
import com.ginkgocap.ywxt.util.ConvertUtil;
import com.ginkgocap.ywxt.util.DateFunc;
import com.ginkgocap.ywxt.util.PageUtil;

@Service("codeService")
public class CodeServiceImpl implements CodeService {
	@Autowired
	private CodeDao codeDao;
	@Autowired
	private CodeLogService codeLogService;
	@Autowired
	RCodeDockDao rCodeDockDao;
	@Resource
	private MessageChannel synsetCodeChangeChannel0;
	private Logger logger = LoggerFactory.getLogger(getClass());

	public Code selectByPrimarKey(long id) {
		return codeDao.selectByPrimarKey(id);
	}
	
	public List<Code> selectByGroupAndLevel(String group, int level) {
		String[] strs = group.split(",");
		List<Code> list = new ArrayList<Code>();
		for (String str : strs) {
			if (!str.equals("")) {
				list.addAll(codeDao.selectByGroupAndLevel(str, level));
			}
		}
		return list;
	}

	public Code insert(Code code) {
		if (code.getUseType() == 0 && code.getOrderNo() != 0) {
			// 修改冲突序号
			List<Code> codes = codeDao.selectByOrderNo(code.getRoot());
			int now = code.getOrderNo();
			int last = now;
			int tmp = 0;
			for (Code code2 : codes) {
				if (now <= code2.getOrderNo()) {// 只考虑大于要设置的序号的情况
					tmp = code2.getOrderNo();// 取出要从新设置的分词序号
					while (tmp <= last)
						tmp++;
					last = tmp;
					code2.setOrderNo(tmp);
					codeDao.update(code2);
				}
			}
		}
		code = codeDao.insert(code);
		StringBuffer number = new StringBuffer();
		number.append(code.getId());
		String parent = null;
		parent = code.getType();
		while (!"0".equals(parent)) {
			Code parentCode = codeDao.selectByPrimarKey(Long.parseLong(parent));
			if (parentCode != null) {
				number.insert(0, "-");
				number.insert(0, parentCode.getId());
				parent = parentCode.getType();
			}
		}
		code.setNumber(number.toString());
		codeDao.update(code);

		if (code.getUseType() == 0) {// 只有系统分词才进行如下操作
		// 写操作记录
			CodeLog log = new CodeLog();
			log.setContent("创建分词：" + code.getName());
			log.setCreateBy(code.getCreateBy());
			log.setCreateById(code.getCreator());
			log.setSysItemId(code.getId());
			codeLogService.insert(log);
			// 检测展示序号
			if (code.getOrderNo() != 0) {
				CodeLog log1 = new CodeLog();
				log1.setContent("设置展示序号：" + code.getOrderNo());
				log1.setCreateBy(code.getCreateBy());
				log1.setCreateById(code.getCreator());
				log1.setSysItemId(code.getId());
				codeLogService.insert(log1);
			}
			// 检测合并分词
			if (StringUtils.isNotBlank(code.getSynsetIds())) {
				String synsetIds = code.getSynsetIds();
				String synsetNames = code.getSynsetNames();
				String remark = "";
				if (",".equals(StringUtils.right(synsetNames, 1))) {
					remark = StringUtils.substringBeforeLast(synsetNames, ",");
					remark = "添加同义分词：" + remark;
				}
				CodeLog log1 = new CodeLog();
				log1.setContent(remark);
				log1.setCreateBy(code.getCreateBy());
				log1.setCreateById(code.getCreator());
				log1.setSysItemId(code.getId());
				codeLogService.insert(log1);

				String ids[] = StringUtils.split(synsetIds, ',');
				if (ids != null) {
					Set<String> codes = new HashSet<String>();
					for (String string : ids) {
						if (StringUtils.isNumeric(string)) {
							Code tmp = codeDao.selectByPrimarKey(Long
									.valueOf(string));
							tmp.setSysItem(code.getName());
							tmp.setSysItemId(code.getId());
							codeDao.update(tmp);
							codes.add(string);
						}
					}
					updateRefInfo(code.getId(), code.getName(), codes);
				}
			}
			// 获取上级的信息
			if (code != null) {
				Code superiorsCode = codeDao.selectFatherNodeById(code.getId());
				if (superiorsCode != null) {
					superiorsCode.setHasChild(1);// 表示上级有下级
					codeDao.update(superiorsCode);
				}
			}

		}
		return code;
	}

	public void update(Code code) {
		Code old = codeDao.selectByPrimarKey(code.getId());

		if (code.getUseType() == 0 && code.getOrderNo() != 0
				&& code.getOrderNo() != old.getOrderNo()) {
			// 修改冲突序号
			List<Code> codes = codeDao.selectByOrderNo(code.getRoot());
			int now = code.getOrderNo();
			int last = now;
			int tmp = 0;
			for (Code code2 : codes) {
				if (now <= code2.getOrderNo()) {// 只考虑大于要设置的序号的情况
					tmp = code2.getOrderNo();// 取出要从新设置的分词序号
					while (tmp <= last)
						tmp++;
					last = tmp;
					code2.setOrderNo(tmp);
					codeDao.update(code2);
				}
			}
		}

		StringBuffer number = new StringBuffer();
		number.append(code.getId());
		String parent = null;
		parent = code.getType();
		while (!"0".equals(parent)) {
			Code parentCode = codeDao.selectByPrimarKey(Long.parseLong(parent));
			if (parentCode != null) {
				number.insert(0, "-");
				number.insert(0, parentCode.getId());
				parent = parentCode.getType();
			}
		}
		code.setNumber(number.toString());
		codeDao.update(code);

		if (code.getUseType() == 0) {// 只有系统分词才进行如下操作
		// 写操作记录
			if (!old.getName().equals(code.getName())) {
				CodeLog log1 = new CodeLog();
				log1.setContent("修改分词名称：" + code.getName() + ",旧名称："
						+ old.getName());
				log1.setCreateBy(code.getCreateBy());
				log1.setCreateById(code.getCreator());
				log1.setSysItemId(code.getId());
				codeLogService.insert(log1);
			}
			// 检测展示序号
			if (code.getOrderNo() != old.getOrderNo()) {
				CodeLog log1 = new CodeLog();
				if (code.getOrderNo() == 0) {
					log1.setContent("取消展示序号：" + old.getOrderNo());
				} else {
					log1.setContent("设置展示序号：" + code.getOrderNo() + ",旧展示序号："
							+ old.getOrderNo());
				}
				log1.setCreateBy(code.getCreateBy());
				log1.setCreateById(code.getCreator());
				log1.setSysItemId(code.getId());
				codeLogService.insert(log1);
			}
			// 检测合并分词
			// if(StringUtils.isNotBlank(code.getSynsetIds())){
			// 查询旧的同义词
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("useType", 1);
			map.put("sysItemId", code.getId());
			List<Map> lt = codeDao.findByMap(map);
			Map<String, String> oldcodes = new HashMap<String, String>();
			for (Map map2 : lt) {
				oldcodes.put(String.valueOf(map2.get("id")),
						String.valueOf(map2.get("name")));
			}

			String synsetIds = code.getSynsetIds();
			String synsetNames = code.getSynsetNames();
			Map<String, String> newcodes = new HashMap<String, String>();
			String ids[] = StringUtils.split(synsetIds, ',');
			String names[] = StringUtils.split(synsetNames, ',');
			if (ids != null) {
				for (int i = 0; i < ids.length; i++) {
					if (StringUtils.isNotBlank(ids[i])) {
						newcodes.put(ids[i], names[i]);
					}
					if (StringUtils.isNumeric(ids[i])) {
						Code tmp = codeDao.selectByPrimarKey(Long
								.valueOf(ids[i]));
						tmp.setSysItem(code.getName());
						tmp.setSysItemId(code.getId());
						codeDao.update(tmp);
					}
				}
			}

			Collection<String> news = new ArrayList<String>(newcodes.keySet());// 新增加的
			news.removeAll(oldcodes.keySet());
			Collection<String> deletes = new ArrayList<String>(
					oldcodes.keySet());// 取消的
			deletes.removeAll(newcodes.keySet());
			StringBuffer newStr = new StringBuffer();
			for (String string : news) {
				newStr.append(newcodes.get(string)).append(",");
			}
			if (newStr.length() > 0) {
				newStr.setLength(newStr.length() - 1);
			}
			StringBuffer oldStr = new StringBuffer();
			for (String string : deletes) {
				oldStr.append(oldcodes.get(string)).append(",");
				Code tmp = codeDao.selectByPrimarKey(Long.valueOf(string));
				tmp.setSysItem("");
				tmp.setSysItemId(0);
				codeDao.update(tmp);
			}
			if (oldStr.length() > 0) {
				oldStr.setLength(oldStr.length() - 1);
			}
			if (oldStr.length() > 0) {
				CodeLog log1 = new CodeLog();
				log1.setContent("取消同义分词：" + oldStr);
				log1.setCreateBy(code.getCreateBy());
				log1.setCreateById(code.getCreator());
				log1.setSysItemId(code.getId());
				codeLogService.insert(log1);
			}
			if (newStr.length() > 0) {
				CodeLog log2 = new CodeLog();
				log2.setContent("添加同义分词：" + newStr);
				log2.setCreateBy(code.getCreateBy());
				log2.setCreateById(code.getCreator());
				log2.setSysItemId(code.getId());
				codeLogService.insert(log2);
			}
			if (news.size() > 0) {
				Set<String> codes = new HashSet<String>(newcodes.keySet());
				codes.removeAll(oldcodes.keySet());
				updateRefInfo(code.getId(), code.getName(), codes);
			}

			List<Code> listc = codeDao.selectChildNodeById(code.getId());// 获取下级的行数
			if (listc != null && listc.size() > 0) {// 说明有下级
				code.setHasChild(1);// 本级的信息标示一下有下级信息
			} else {
				code.setHasChild(0);// 反之，标示一下没有下级信息
			}
			codeDao.update(code);
		}
	}

	// }

	public void delete(long id) {
		Map<String, Object> map = new HashMap<String, Object>();
		map.put("parentId", "" + id);
		List<Map> lt = codeDao.findByMap(map);
		if (lt != null && lt.size() > 0) {
			for (Map map2 : lt) {
				// long sub = Long.valueOf(String.valueOf(map2.get("id")));
				long sub = (Long) map2.get("id");
				delete(sub);
			}
		}
		long superiorsId = id;
		// 删除子节点
		List<Code> childList = codeDao.selectChildNodeById(id);// 获取子节点
		for (Code code : childList) {// 删除它的所有的子节点
			codeDao.delete(code.getId());
		}
		// 获取父节点
		Code code = codeDao.selectFatherNodeById(superiorsId);
		if (code != null) {
			// 获取本节点的信息
			Code brotherCode = codeDao.selectByPrimarKey(superiorsId);
			// 获取兄弟节点
			List<Code> brotherList = codeDao.selectBrotherNodeById(Long
					.parseLong(brotherCode.getType()));
			if (brotherList != null && brotherList.size() > 0) {// 不为null
																// 说明有兄弟节点
				code.setHasChild(1);
			} else {
				code.setHasChild(0);// 反之，没有
			}
			// 更新父节点
			codeDao.update(code);
		}
		// 删除本节点
		codeDao.delete(id);
	}

	@Override
	public List<Code> selectByParams(int root, String keywords, int useType,
			long startRow, int pageSize) {
		Map<String, Object> params = new HashMap<String, Object>();
		if (keywords != null && keywords.length() != 0) {
			params.put("keywords", "%"+keywords + "%");
		}
		if (useType > -1) {
			params.put("useType", useType);
		}
		if (startRow >= 0 && pageSize > 0) {
			params.put("startRow", startRow);
			params.put("pageSize", pageSize);
		}
		if (root > 0 && root < 4) {
			params.put("root", root);
		} else if (root >= 4) {
			params.put("industry", 1);
		}
		return codeDao.selectByParams(params);
	}

	@Override
	public List<Code> selectByName(String name) {
		return codeDao.selectByName(name);
	}

	@Override
	public List<Code> selectByName(String name, int root) {
		return codeDao.selectByName(name, root);
	}

	@Override
	public List<Code> selectAll() {
		// TODO Auto-generated method stub
		return codeDao.selectAll();
	}

	
	//不确定是否正确，测试一下
	@Override
	public List<Map> findByMap(Map<String, Object> map) {
		List<Map> list = codeDao.findByMap(map);
		List<Map> newList = new ArrayList<Map>();
		logger.info("begin find code by map");
		if (list != null && list.size() > 0) {
			logger.info("begin find code size:" + list.size());
			for (Map m : list) {
				logger.info("begin find code root:" + (Integer) m.get("root"));
				if ((Integer) m.get("root") == 1) {
					String tzNumber = (String) m.get("number");
					if (StringUtils.isNotBlank(tzNumber)) {
						logger.info("begin find code tzNumber:" + tzNumber);
						List<RCodeDock> rcd = rCodeDockDao.dockTz(tzNumber);
						String rz = "";
						if (rcd != null && rcd.size() > 0) {
							for (RCodeDock r : rcd) {
								rz += r.getRzName() + ",";
							}
							rz = StringUtils.removeEnd(rz, ",");
						}
						logger.info("begin find code dockStr:" + rz);
						m.put("dockStr", rz);
						m.put("dockList", rcd);
					}
				}
				if ((Integer) m.get("root") == 2) {
					String rzNumber = (String) m.get("number");
					if (StringUtils.isNotBlank(rzNumber)) {
						logger.info("begin find code tzNumber:" + rzNumber);
						List<RCodeDock> rcd = rCodeDockDao.dockRz(rzNumber);
						String tz = "";
						if (rcd != null && rcd.size() > 0) {
							for (RCodeDock r : rcd) {
								logger.info("r.id:" + r.getId());
								tz += r.getTzName() + ",";
							}
							tz = StringUtils.removeEnd(tz, ",");
						}
						logger.info("begin find code dockStr:" + tz);
						m.put("dockStr", tz);
						m.put("dockList", rcd);
					}
				}
				newList.add(m);
			}
		}
		return newList;
	}

	/**
	 * 更新关联数据 个人资料部分、需求部分、mongo
	 * 
	 * @param codes
	 * @return
	 */
	private boolean updateRefInfo(long id, String name, Collection<String> codes) {
		logger.debug("send a code change msg");
		HashMap<String, Object> map = new HashMap<String, Object>();
		map.put("id", id);
		map.put("name", name);
		map.put("codes", codes);
		String jsonStr = ConvertUtil.mapToJson(map);
		logger.debug(jsonStr);
		GenericMessage<?> msg = new GenericMessage<String>(jsonStr);
		boolean flag = synsetCodeChangeChannel0.send(msg);
		if (flag) {
			logger.debug("send the code change msg success");
		} else {
			logger.error("send the code change msg error");
		}
		return flag;
	}

	@Override
	public Map<String, Object> selectByParam(String name, String createBy,
			String sysItem, String startTimer, String endTimer, String type,
			DataGridModel dgm) {
		if (StringUtils.isNotBlank(startTimer)) {// 创建开始时间不为空的时候
			if (!StringUtils.isNotBlank(endTimer)) {// 创建结束时间为空的时候，默认当前时间
				endTimer = DateFunc.getDate();
			}
		}
		Integer start = (dgm.getPage() - 1) * dgm.getRows();
		Integer size = dgm.getRows();
		List<Code> lt = null;
		long total = 0l;
		try {
			lt = codeDao.selectByParam(name, createBy, sysItem, startTimer,
					endTimer, type, start, size);
			total = codeDao.selectByParamCount(name, createBy, sysItem,
					startTimer, type, endTimer);
			logger.debug("selectByParam --------->name:" + name);
			logger.debug("selectByParam --------->createBy:" + createBy);
			logger.debug("selectByParam --------->sysItem:" + sysItem);
			logger.debug("selectByParam --------->startTimer:" + startTimer);
			logger.debug("selectByParam --------->endTimer:" + endTimer);
			logger.debug("selectByParam --------->type:" + type);
			if (lt != null && lt.size() > 0) {
				for (Code c : lt) {
					if (StringUtils.isNotBlank(c.getCtime())) {
						String ctime = c.getCtime();
						ctime = ctime.substring(0, 19);// 截取创建时间字段
						c.setCtime(ctime);
					}
				}
			}
		} catch (Exception e) {
			logger.error("selectByParam is error");
			e.printStackTrace();
		}
		Map<String, Object> result = new HashMap<String, Object>();
		result.put("total", total);
		result.put("rows", lt);
		return result;
	}

	/**
	 * 查询子节点的分词信息
	 * 
	 * @param id
	 * @return List<Code>
	 */
	public List<Code> selectChildNodeById(long id) {
		return codeDao.selectChildNodeById(id);
	}

	/**
	 * 查询兄弟节点的分词信息
	 * 
	 * @param id
	 * @return List<Code>
	 */
	public List<Code> selectBrotherNodeById(long id) {
		return codeDao.selectBrotherNodeById(id);
	}

	@Override
	public Map<String, Object> selectCodeByPageUtil(int userType, int industry,
			int level, int pageIndex, int pageSize) {

		int count = (int) codeDao.SelectCountByUserTypeIndustry(userType,
				industry, level);
		List<Code> codeList = codeDao.SelectByUserTypeIndustry(userType,
				industry, level, pageIndex, pageSize);
		PageUtil pu = new PageUtil(count, pageIndex, pageSize);
		Map<String, Object> values = new HashMap<String, Object>();
		values.put("results", codeList);
		values.put("page", pu);

		return values;
	}
 
	@Override
	public List<CodeRegion> selectAreaList(Long pid){
		return codeDao.selectAreaList(pid); 
	}
	
	@Override
	public Map<String, Object> findMenuTree(int page,int pagesize){
		List<Code> codes = codeDao.selectAllOrderByNumberAsc();
    	Map<String, Object> menuTree = new LinkedHashMap<String, Object>();
    	for (Code code :codes) {
    		String[] indexLevel = code.getNumber().split("-");
    		String nid = null;
    		String pid = null;
    		int level = indexLevel.length;
    		//String rootKey = String.valueOf(code.getRoot());
    		if(level == 1){
    		   nid = indexLevel[0];
    		   pid = "0";
       		   TreeNode treeNode = new TreeNode(nid,pid);
       		   treeNode.setCode(code);
       		   List<TreeNode> menuList = new ArrayList<TreeNode>();
       		   menuList.add(treeNode);
       		   menuTree.put(treeNode.getCode().getName(), menuList);
       		   //menuTree.put(rootKey, menuList);
    		}
    		else {
     		   nid = indexLevel[level-1];
     		   pid = indexLevel[level-2];
       		   TreeNode treeNode = new TreeNode(nid,pid);
       		   treeNode.setCode(code);
       		   /**调试开关
       		   if(level > 2 ) {
       			   logger.debug(treeNode.getCode().getNumber());
           		   JSONArray array_0 = JSONArray.fromObject(menuTree);  
           		   logger.debug(array_0.toString());  
       		   }
               **/
       		   for (Entry<String, Object> entry : menuTree.entrySet()) {
       			    @SuppressWarnings("unchecked")
					List<TreeNode> tmp_nodes = (List<TreeNode>) entry.getValue();
       			    logger.debug(tmp_nodes.size()+"");;
       			    for(TreeNode node_1 : tmp_nodes){
       			    	logger.debug(node_1.getNid()+","+treeNode.getPid());;
           			    if( node_1.getNid().equals(treeNode.getPid()) ){
           			    	node_1.getChildren().add(treeNode);
           			    }
           			    else{
           			    	findNodeList(node_1,treeNode);
           			    }
       			    }
       		   }
			}
		}
    	menuTree.put("Totals", codes.size());
		return menuTree;
	}
	
	/**
	 * 功能描述：递归查找
	 * @param treeNode
	 * @param storeNode
	 * @return
	 */
	private boolean findNodeList(TreeNode treeNode,TreeNode storeNode){
        boolean isCreate = false;
	    if( treeNode.getChildren().size() > 0 ){
	    	List<TreeNode> nodes = treeNode.getChildren();
    		for(TreeNode node : nodes){
   			    if( node.getNid().equals(storeNode.getPid()) ){
   			    	node.getChildren().add(storeNode);
   			    	isCreate = true;
   			    }else{
   			    	findNodeList(node,storeNode);
   			    }
    		}
	    }
	    return isCreate;
	}

	/*
	 * (non-Javadoc)
	 * @see com.ginkgocap.ywxt.metadata.service.code.CodeService#getCataLogMaxId()
	 */
	@Override
	public Long getCataLogMaxId() {
		return (Long)codeDao.selectCataLogMaxId();
	}

	
}
